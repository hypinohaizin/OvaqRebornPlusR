package net.shoreline.client.impl.module.exploit;

import net.minecraft.enchantment.Enchantments;
import net.minecraft.entity.Entity;
import net.minecraft.entity.EquipmentSlot;
import net.minecraft.entity.projectile.FireworkRocketEntity;
import net.minecraft.item.*;
import net.minecraft.network.packet.c2s.play.ClientCommandC2SPacket;
import net.minecraft.network.packet.c2s.play.HandSwingC2SPacket;
import net.minecraft.network.packet.c2s.play.PlayerActionC2SPacket;
import net.minecraft.network.packet.c2s.play.PlayerInteractItemC2SPacket;
import net.minecraft.screen.slot.SlotActionType;
import net.minecraft.util.Hand;
import net.minecraft.util.math.BlockPos;
import net.minecraft.util.math.Direction;
import net.shoreline.client.api.config.Config;
import net.shoreline.client.api.config.setting.EnumConfig;
import net.shoreline.client.api.module.ModuleCategory;
import net.shoreline.client.api.module.ToggleModule;
import net.shoreline.client.impl.event.TickEvent;
import net.shoreline.client.impl.event.entity.projectile.FireworkVelocityEvent;
import net.shoreline.client.impl.event.item.TridentWaterEvent;
import net.shoreline.client.impl.event.network.DisconnectEvent;
import net.shoreline.client.impl.event.network.EncodeYawEvent;
import net.shoreline.client.init.Managers;
import net.shoreline.client.mixin.accessor.AccessorFireworkRocketEntity;
import net.shoreline.client.util.math.timer.CacheTimer;
import net.shoreline.client.util.math.timer.Timer;
import net.shoreline.client.util.player.EnchantmentUtil;
import net.shoreline.client.util.string.EnumFormatter;
import net.shoreline.eventbus.annotation.EventListener;
import net.shoreline.eventbus.event.StageEvent;

/**
 * @author xgraza & hockeyl8
 * @since 1.0
 */
public final class DisablerModule extends ToggleModule
{
    private static DisablerModule INSTANCE;

    Config<Mode> modeConfig = register(new EnumConfig<>("Mode", "The mode for disabling anticheat checks", Mode.GRIM_TRIDENT, Mode.values()));

    private final Timer fireworkTimer = new CacheTimer();

    public DisablerModule()
    {
        super("Disabler", "Disables anticheat checks", ModuleCategory.EXPLOITS);
        INSTANCE = this;
    }

    public static DisablerModule getInstance()
    {
        return INSTANCE;
    }

    @Override
    public String getModuleData()
    {
        return isGrim() ? "Grim" : EnumFormatter.formatEnum(modeConfig.getValue());
    }

    @EventListener
    public void onDisconnect(DisconnectEvent event)
    {
        disable();
    }

    @EventListener
    public void onTick(TickEvent event)
    {
        if (event.getStage() != StageEvent.EventStage.PRE)
        {
            return;
        }
        if (modeConfig.getValue() == Mode.GRIM_TRIDENT)
        {
            if (mc.player.isUsingItem())
            {
                return;
            }

            int tridentSlot = -1;
            for (int i = 0; i < 9; ++i)
            {
                final ItemStack stack = mc.player.getInventory().getStack(i);
                if (!stack.isEmpty() && stack.getItem() instanceof TridentItem)
                {
                    if (EnchantmentUtil.getLevel(stack, Enchantments.RIPTIDE) > 0)
                    {
                        tridentSlot = i;
                        break;
                    }
                }
            }

            if (tridentSlot == -1)
            {
                return;
            }

            Managers.INVENTORY.setSlot(tridentSlot);
            Managers.NETWORK.sendSequencedPacket(id -> new PlayerInteractItemC2SPacket(Hand.MAIN_HAND, id, mc.player.getYaw(), mc.player.getPitch()));
            Managers.NETWORK.sendPacket(new PlayerActionC2SPacket(PlayerActionC2SPacket.Action.RELEASE_USE_ITEM, BlockPos.ORIGIN, Direction.DOWN));
            Managers.INVENTORY.syncToClient();
        }
        else if (modeConfig.getValue() == Mode.GRIM_FIREWORK)
        {
            int elytraSlot = -1;
            int fireworkSlot = -1;
            for (int i = 0; i < 36; i++)
            {
                ItemStack stack = mc.player.getInventory().getStack(i);
                if (stack.getItem() instanceof FireworkRocketItem && i < 9)
                {
                    fireworkSlot = i;
                }
                if (stack.getItem() instanceof ElytraItem)
                {
                    elytraSlot = i;
                }
            }
            if (!isBoostedByRocket() && !mc.player.isInFluid() && fireworkSlot != -1)
            {
                if (mc.player.isOnGround())
                {
                    mc.player.jump();
                }
                else
                {
                    Managers.MOVEMENT.setMotionY(-0.05);
                }
                if (fireworkTimer.passed(1700) && !mc.player.isOnGround() && mc.player.getVelocity().y < 0.0)
                {
                    if (mc.player.getEquippedStack(EquipmentSlot.CHEST).getItem() != Items.ELYTRA && elytraSlot != -1)
                    {
                        mc.interactionManager.clickSlot(0, elytraSlot < 9 ? elytraSlot + 36 : elytraSlot, 0, SlotActionType.PICKUP, mc.player);
                        mc.interactionManager.clickSlot(0, 6, 0, SlotActionType.PICKUP, mc.player);
                        mc.interactionManager.clickSlot(0, elytraSlot < 9 ? elytraSlot + 36 : elytraSlot, 0, SlotActionType.PICKUP, mc.player);
                    }
                    Managers.NETWORK.sendPacket(new ClientCommandC2SPacket(mc.player, ClientCommandC2SPacket.Mode.START_FALL_FLYING));
                    Managers.INVENTORY.setSlot(fireworkSlot);
                    Managers.NETWORK.sendSequencedPacket(id -> new PlayerInteractItemC2SPacket(Hand.MAIN_HAND, id, mc.player.getYaw(), mc.player.getPitch()));
                    Managers.NETWORK.sendPacket(new HandSwingC2SPacket(Hand.MAIN_HAND));
                    Managers.INVENTORY.syncToClient();
                    fireworkTimer.reset();
                    if (mc.player.getEquippedStack(EquipmentSlot.CHEST).getItem() == Items.ELYTRA && elytraSlot != -1)
                    {
                        mc.interactionManager.clickSlot(0, 6, 0, SlotActionType.PICKUP, mc.player);
                        mc.interactionManager.clickSlot(0, elytraSlot < 9 ? elytraSlot + 36 : elytraSlot, 0, SlotActionType.PICKUP, mc.player);
                        mc.interactionManager.clickSlot(0, 6, 0, SlotActionType.PICKUP, mc.player);
                    }
                }
            }
        }
    }

    @EventListener
    public void onTridentWaterCheck(TridentWaterEvent event)
    {
        if (modeConfig.getValue().equals(Mode.GRIM_TRIDENT))
        {
            event.cancel();
        }
    }

    @EventListener
    public void onFireworkVelocity(FireworkVelocityEvent event)
    {
        if (modeConfig.getValue() == Mode.GRIM_FIREWORK)
        {
            event.cancel();
        }
    }

    @EventListener
    public void onEncodeYaw(EncodeYawEvent event)
    {
        if (isYawOverflow())
        {
            event.cancel();
        }
    }

    public boolean isBoostedByRocket()
    {
        for (Entity entity : mc.world.getEntities())
        {
            if (entity instanceof FireworkRocketEntity rocket
                    && ((AccessorFireworkRocketEntity) rocket).hookWasShotByEntity()
                    && ((AccessorFireworkRocketEntity) rocket).hookGetShooter() == mc.player)
            {
                return true;
            }
        }
        return false;
    }

    private boolean isGrim()
    {
        return modeConfig.getValue().name().toLowerCase().contains("grim");
    }

    public boolean isGrimFirework()
    {
        return isEnabled() && modeConfig.getValue() == Mode.GRIM_FIREWORK;
    }

    public boolean isYawOverflow()
    {
        return !mc.player.isFallFlying() && modeConfig.getValue() == Mode.GRIM_OVERFLOW;
    }

    public boolean grimFireworkCheck()
    {
        return isGrimFirework() && !isBoostedByRocket();
    }

    public boolean grimFireworkCheck2()
    {
        return isGrimFirework() && isBoostedByRocket();
    }

    private enum Mode
    {
        GRIM_TRIDENT,
        GRIM_FIREWORK,
        GRIM_OVERFLOW
    }
}
