package net.shoreline.client.impl.module.exploit;

import net.minecraft.block.BlockState;
import net.minecraft.block.ScaffoldingBlock;
import net.minecraft.entity.Entity;
import net.minecraft.entity.decoration.ItemFrameEntity;
import net.minecraft.item.EnderPearlItem;
import net.minecraft.item.ItemStack;
import net.minecraft.item.Items;
import net.minecraft.network.packet.c2s.play.HandSwingC2SPacket;
import net.minecraft.network.packet.c2s.play.PlayerActionC2SPacket;
import net.minecraft.network.packet.c2s.play.PlayerInteractEntityC2SPacket;
import net.minecraft.network.packet.c2s.play.PlayerInteractItemC2SPacket;
import net.minecraft.screen.slot.SlotActionType;
import net.minecraft.util.Hand;
import net.minecraft.util.hit.BlockHitResult;
import net.minecraft.util.math.*;
import net.shoreline.client.api.config.Config;
import net.shoreline.client.api.config.setting.BooleanConfig;
import net.shoreline.client.api.config.setting.NumberConfig;
import net.shoreline.client.api.module.ModuleCategory;
import net.shoreline.client.impl.module.ObsidianPlacerModule;
import net.shoreline.client.init.Managers;
import net.shoreline.client.util.player.RayCastUtil;
import net.shoreline.client.util.player.RotationUtil;


public class PearlPhaseModule extends ObsidianPlacerModule {

    Config<Integer> pitchConfig = register(new NumberConfig<>("Pitch", "The pitch to throw pearls", 70, 85, 90));
    Config<Boolean> swapAltConfig = register(new BooleanConfig("SwapAlternative", "Uses inventory swap for swapping to pearls", true));
    Config<Boolean> attackConfig = register(new BooleanConfig("Attack", "Attacks entities in the way of the pearl phase", false));
    // private final Config<Boolean> raytraceConfig = new BooleanConfig("Raytrace", "Checks the landing position of the pearl", false);
    Config<Boolean> swingConfig = register(new BooleanConfig("Swing", "Swings the hand when throwing pearls", true));
    Config<Boolean> selfFillConfig = register(new BooleanConfig("SelfFill", "Automatically fills blocks you are phasing on", false));

    public PearlPhaseModule() {
        super("PearlPhase", "Phases through blocks using ender pearls", ModuleCategory.EXPLOITS);
    }

    @Override
    public void onEnable() {
        if (mc.player == null) {
            return;
        }

        int pearlSlot = -1;
        for (int i = 0; i < 45; i++) {
            ItemStack stack = mc.player.getInventory().getStack(i);
            if (stack.getItem() instanceof EnderPearlItem) {
                pearlSlot = i;
                break;
            }
        }

        if (pearlSlot == -1 || mc.player.getItemCooldownManager().isCoolingDown(Items.ENDER_PEARL)) {
            disable();
            return;
        }

        float prevYaw = mc.player.getYaw();
        float prevPitch = mc.player.getPitch();
        Vec3d pearlTargetVec = new Vec3d(Math.floor(mc.player.getX()) + 0.5, 0.0, Math.floor(mc.player.getZ()) + 0.5);
        float[] rotations = RotationUtil.getRotationsTo(mc.player.getEyePos(), pearlTargetVec);
        float yaw = rotations[0] + 180.0f;

        if (attackConfig.getValue()) {
            BlockHitResult hitResult = (BlockHitResult) RayCastUtil.rayCast(3.0, new float[] { yaw, 60.0f });
            for (Entity entity : mc.world.getOtherEntities(null, new Box(hitResult.getBlockPos()).expand(0.2))) {
                if (entity instanceof ItemFrameEntity itemFrameEntity) {
                    if (!itemFrameEntity.getHeldItemStack().isEmpty()) {
                        Managers.NETWORK.sendPacket(PlayerInteractEntityC2SPacket.attack(entity, mc.player.isSneaking()));
                    }
                    Managers.NETWORK.sendPacket(PlayerInteractEntityC2SPacket.attack(entity, mc.player.isSneaking()));
                    Managers.NETWORK.sendPacket(new HandSwingC2SPacket(Hand.MAIN_HAND));
                }
            }

            BlockState state = mc.world.getBlockState(mc.player.getBlockPos());
            if (state.getBlock() instanceof ScaffoldingBlock) {
                Managers.NETWORK.sendPacket(new PlayerActionC2SPacket(PlayerActionC2SPacket.Action.START_DESTROY_BLOCK, mc.player.getBlockPos(), Direction.UP));
                Managers.NETWORK.sendPacket(new PlayerActionC2SPacket(PlayerActionC2SPacket.Action.STOP_DESTROY_BLOCK, mc.player.getBlockPos(), Direction.UP));
            }
        }

        // Optional: Self-fill blocks beneath player
        if (selfFillConfig.getValue())
        {
            float yaw1 = yaw % 360.0f;
            if (yaw1 < 0.0f)
            {
                yaw1 += 360.0f;
            }

            BlockPos blockPos = mc.player.getBlockPos();
            if (yaw1 >= 22.5 && yaw1 < 67.5)
            {
                blockPos = blockPos.south().west();
            }
            else if (yaw1 >= 67.5 && yaw1 < 112.5)
            {
                blockPos = blockPos.west();
            }
            else if (yaw1 >= 112.5 && yaw1 < 157.5)
            {
                blockPos = blockPos.north().west();
            }
            else if (yaw1 >= 157.5 && yaw1 < 202.5)
            {
                blockPos = blockPos.north();
            }
            else if (yaw1 >= 202.5 && yaw1 < 247.5)
            {
                blockPos = blockPos.north().east();
            }
            else if (yaw1 >= 247.5 && yaw1 < 292.5)
            {
                blockPos = blockPos.east();
            }
            else if (yaw1 >= 292.5 && yaw1 < 337.5)
            {
                blockPos = blockPos.south().east();
            }
            else
            {
                blockPos = blockPos.south();
            }

            int slot = getResistantBlockItem();
            if (slot != -1 && blockPos != null && !mc.world.getBlockState(blockPos.down()).isReplaceable())
            {
                Managers.INTERACT.placeBlock(blockPos, slot, strictDirectionConfig.getValue(), false, true, (state, angles) ->
                {
                    if (state)
                    {
                        Managers.ROTATION.setRotationSilent(angles[0], angles[1]);
                    }
                    else
                    {
                        Managers.ROTATION.setRotationSilentSync();
                    }
                });
            }
        }

        setRotationSilent(yaw, pitchConfig.getValue());

        if (swapAltConfig.getValue()) {
            mc.interactionManager.clickSlot(0, pearlSlot < 9 ? pearlSlot + 36 : pearlSlot, 0, SlotActionType.PICKUP, mc.player);
            mc.interactionManager.clickSlot(0, mc.player.getInventory().selectedSlot + 36, 0, SlotActionType.PICKUP, mc.player);
            mc.interactionManager.clickSlot(0, pearlSlot < 9 ? pearlSlot + 36 : pearlSlot, 0, SlotActionType.PICKUP, mc.player);
        } else if (pearlSlot < 9) {
            Managers.INVENTORY.setSlot(pearlSlot);
        }

        Managers.NETWORK.sendSequencedPacket(id -> new PlayerInteractItemC2SPacket(Hand.MAIN_HAND, id, yaw, pitchConfig.getValue()));
        Managers.PEARL.setLastThrownAngles(new float[] { yaw, pitchConfig.getValue() });

        if (swingConfig.getValue()) {
            mc.player.swingHand(Hand.MAIN_HAND);
        } else {
            Managers.NETWORK.sendPacket(new HandSwingC2SPacket(Hand.MAIN_HAND));
        }

        if (swapAltConfig.getValue()) {
            mc.interactionManager.clickSlot(0, pearlSlot < 9 ? pearlSlot + 36 : pearlSlot, 0, SlotActionType.PICKUP, mc.player);
            mc.interactionManager.clickSlot(0, mc.player.getInventory().selectedSlot + 36, 0, SlotActionType.PICKUP, mc.player);
            mc.interactionManager.clickSlot(0, pearlSlot < 9 ? pearlSlot + 36 : pearlSlot, 0, SlotActionType.PICKUP, mc.player);
        } else if (pearlSlot < 9) {
            Managers.INVENTORY.syncToClient();
        }

        setRotationClient(prevYaw, prevPitch);
        disable();
    }
}